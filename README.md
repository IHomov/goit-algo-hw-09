## Видача решти — Жадібний алгоритм і Динамічне програмування

## Це завдання демонструє два підходи до задачі видачі решти: жадібний алгоритм та алгоритм динамічного програмування.

Завдання
Реалізувати дві функції:

find_coins_greedy(sum, coins) — використовує жадібний підхід для видачі решти.

## find_min_coins(sum, coins) — застосовує динамічне програмування для знаходження мінімальної кількості монет.

Приклад

coins = [50, 10, 2, 1]
sum = 113

---

# Жадібний алгоритм

find_coins_greedy(113, coins) → {50: 2, 10: 1, 2: 1, 1: 1}

# Динамічне програмування

find_min_coins(113, coins) → {50: 2, 10: 1, 2: 1, 1: 1}
У цьому випадку обидва алгоритми дають однаковий результат, але так буває не завжди.

---

# _Порівняння алгоритмів_

| Характеристика        | Жадібний алгоритм     | Динамічне програмування  |
| --------------------- | --------------------- | ------------------------ |
| Швидкодія             | Дуже швидкий (O(n))   | Повільніший (O(sum × n)) |
| Точність              | Не завжди оптимальний | Завжди мінімум монет     |
| Памʼять               | Мінімальна            | Потребує більше памʼяті  |
| Складність реалізації | Проста                | Складніша                |

# _Висновок_

Жадібний підхід добре працює з типовими системами монет (наприклад, грошовими), де найбільші номінали зручно комбінуються.

Динамічне програмування надає гарантовано оптимальний результат, особливо при нестандартних номіналах або складних сумах, але вимагає більше ресурсів.
